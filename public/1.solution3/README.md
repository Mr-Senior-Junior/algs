# Реализация 3 - Метод взвешенного быстрого объединения

Поскольку в реализации 2 (метод быстрого объединения) имела место зависимость эффективности работы алгоритма от характера входных данных, то возникает логичное желание избиваться от данного недостатка.  

> При вводе значений 0-1, 1-2, 2-3 и т.д. будет формироваться *глубокое* и *одностороннее* дерево, поиск по которому будет все время производится по всей длине.  

При выполнении операции *объединение* можно не произвольным образом соединять второе дерево с первым (или наоборот), а отслеживать количество узлов в каждом дереве и всегда соединять **меньшее** дерево с **большим**.  
Это изменение требует дополнительного массива, в котором будет храниться размер дерева каждого объекта.  

Вместо такого дерева  
![tree2](/resources/1_connectivity_task/images/tree2.png)

Получим такое дерево  
![tree3](/resources/1_connectivity_task/images/tree3.png)


Ссылки на код в *WANDBOX*  
[Программа на C++](https://wandbox.org/permlink/p1tqbW0Pw2LS1SJf)  
[Программа на Python](https://wandbox.org/permlink/Ljoc0jq0WdIUz5og)  


Исходные файлы с кодом  
[Файл C++](/src/1_connectivity_task/C++/1.3_weighted_fast_union.cpp)
[Файл Python](/src/1_connectivity_task/Python/1.3_weighted_fast_union.py)
