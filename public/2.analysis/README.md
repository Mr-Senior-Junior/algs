# Анализ эффективности алгоритмов


Когда говорят об анализе эффективности алгоритмов, то первым делом вспоминают загадочную букву O. Что она означает на самом деле? И что подразумевается под словом *эффективность*.  

Анализ алгоритмов, отнюдь, дело не из простых. Если вдаваться в подробности, то можно ужаснуться от количества матана, формул и теоретических выкладок. На самом же деле для повседневных рабочих задач достаточно разбираться в небольшом пласте теории и уметь эмпирически сравнивать алгоритмы (запустить и посмотреть, какой быстрее).  


## O-нотация  


Первое с чего можно начать говорить об эффективности алгоритмов - это классификация ресурсов, которые алгоритмы потребляют. А таковых всего 2 - это время (ЦП) и память (RAM). Чтобы оценить время работы алгоритма, необходимо пройтись по каждой инструкции алгоритма, посчитать время ее выполнения на вашей машине, выделить повторяющиеся элементы, затем все просуммировать и получить результат.  

Очевидно, что таким заниматься никто не будет. Во-первых, полученное время будет актуально исключительно для той машины, для которой был произведен расчет. Во-вторых, при точных расчетах невозможно предугадать характер входных данных. Тем не менее, анализируя тот или иной алгоритм, мы можем заметить, что существуют участки кода, которые будут повторяться пропорциональное количеству входных данных раз. Отсюда мы можем составить уравнение.  

Например, у нас есть рандомная программа, которая обрабатывает каждое введенное ей число, помещая его в массив; затем находит максимум, проходя один раз по всем элементам массива; и выводит максимум на экран. Не вдаваясь в подробности используемых команд для каждой операции, скажем, что чтение и запись числа в массив выполняется за константное время *a*. Операции сравнения, записи, инкремента и разыменования при поиске максимума - *b*. Вывод на экран - *c*. Далее заметим, что первые две абстрактные операции (наполнение массива и поиск максимума) будут прямо зависеть от количества вводимых элементов. Таким образом можем выразить время работы алгоритма в общей форме, как функцию *f(N)*:  

```
f(N) = aN + bN + c, где N - количество вводимых чисел
```

Заметим, что данную запись можно сократить:  

```
f(N) = (a + b)N + c
```

Так как *a* и *b* являются константами, то и их сумма также будет являться константой. Замени *a + b* на *k*. Тогда получим:  

```
f(N) = kN + c
```

Отсюда можем сделать вывод, что функция *f(N)* - линейная. Это означает, что если количество входных данных увеличить в 2 раза, то и время работы увеличится в 2 раза.  
И вот мы плавно подходим к O-нотации. Для начала дадим определение:  
*Говорят, что функция g(N) имеет порядок O(f(N)), если существуют такие постоянные k и N0, что g(N) < kf(N) для всех N > N0*  

Таким образом, если мы утверждаем, что *g(N)* - это функция времени работы алгоритма, то *f(N)* - некая асимптота, выше которой *g(N)* не поднимается. Иными словами *O(f(N))* показывает **характер** функции времени работы алгоритма от входных данных.  

В нашем случае, описанном выше, *f(N) = kN + c*, тогда *O(f(N)) = O(kN + c)*.  
Как уже было сказано ранее, O(f(N)) не нужна для точной оценки времени выполнения алгоритма. Она нужна для понимания зависимости времени от количества входных данных. А так же ее удобно использовать для сравнения разных алгоритмов между собой, но там бывают нюансы, связанные с константами.  

Значит, для того, чтобы показать характер функции вышеописанного алгоритма мы можем опустить все константы и тогда останется, что *O(f(N)) = O(N)*.  
Это означает, что функция времени возрастает линейно, прямо пропорционально входным данным.  

Стоит отметить, что O-нотация зачастую включает в себя только старший член многочлена, описывающего эффективность работы алгоритма, т.е. *O(aN⋅N + bN + c) = O(N⋅N)*.  
Данная нотация относится не только к времени работы алгоритма. Ее также можно использовать для оценки потребляемой алгоритмом памяти.  

Наиболее часто встречающиеся *O(f(N))*:  
1. O(1)  
2. O(logN)  
3. O(N)  
4. O(NlogN)  
5. O(N*N)  
6. O(2^N)  

![O-notation](/resources/2_analysis/o-notation.jpg)

